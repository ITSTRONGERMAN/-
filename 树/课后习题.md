# 王道第158页代码题

## 3. 编写后序遍历树的非递归算法

```c
void postorder_2(BinaryTree T) {
    SequenceStack S = initSequenceStack();
    BinaryTreeNode* p = T;
    BinaryTreeNode* r = NULL;

    while (p || !isEmpty(&S)) {
        // 因为后序遍历的顺序是根左右，所以一直遍历左子树，找到最深层次的左子树
        if (p) {
            push(&S, p);
            p = p->lchild;
        }
        else {
         // 获取栈顶元素
            getTop(S, &p);
            if (p->rchild && p->rchild != r) {
                p = p->rchild;
            }
            else {
                pop(&S, &p);
                visit(p);
                r = p;
                p = NULL;
            }
        }
    }
}
```

## **4.试给出二叉树的自下而上、从左到右的层次遍历算法**

```c
void reverselayerorder(BinaryTreeNode* B) {
    if (B == NULL) {
        printf("树为空。\n");
        return;
    }
    Queue Q = initQueue();
    SequenceStack S = initSequenceStack();
    BinaryTreeNode* p;
    enterQueue(&Q, B);
    while (!isEmpty_queue(&Q)) {
        goOutQueue(&Q, &p);
        visit(p);
        push(&S,p);
        if (p->lchild != NULL) enterQueue(&Q, p->lchild);
        if (p->rchild != NULL) enterQueue(&Q, p->rchild);
    }
    printf("\n相反层次遍历：");
    while (!isEmpty(&S)) {
        p=pop(&S);
        printf("%d, ", p->data);
    }
}
```

## **5.  假设二叉树采用二叉链表树存储结构，设计一个非递归算法求二叉树的高度**

```c
int calculateHeightOfBinaryTree(BinaryTree T) {
    if (!T) return -1;
    Queue Q = initQueue();
    enterQueue(&Q, T);
    BinaryTreeNode* p;
    int last = 1, level = 0;
    while (!isEmpty_queue(&Q))
    {
        goOutQueue(&Q, &p);
        if (p->lchild)enterQueue(&Q, p->lchild);
        if (p->rchild)enterQueue(&Q, p->rchild);
        if (Q.front == last) {
            level++;
            last = Q.rear;
        }
    }
    return level;
}
// 递归版
int calculateHeightOfBinaryTree_2(BinaryTree T) {
    if (T==NULL)return 0;
    int ldepth = calculateHeightOfBinaryTree_2(T->lchild);
    int rdepth = calculateHeightOfBinaryTree_2(T->rchild);
    return (ldepth > rdepth ? ldepth : rdepth)+1;                         
}
```

## **6. 二叉树按二叉链表形式存储，试编写一个判断给定二叉树是否是完全二叉树的算法**

```c
bool isCompleteBinaryTree(BinaryTree T) {
    Queue Q = initQueue();
    enterQueue(&Q,T);
    BinaryTreeNode *p;
    while (!isEmpty_queue(&Q))
    {
        goOutQueue(&Q, &p);
        if (p) {
            enterQueue(&Q, p->lchild);
            enterQueue(&Q, p->rchild);
        }
        else {
            while (!isEmpty_queue(&Q))
            {
                goOutQueue(&Q, &p);
                if (p) {
                    return false;
                }
            }
        }
    }
    return true;
}
```

## **7. 假设二叉树是一个采用二叉链表结构存储的二叉树，试设计一个算法，计算一棵给定二叉树双分支节点的个数**

```c
int calculateTwoNodes(BinaryTree T) {
    if (!T)return 0;
    return T->lchild && T->rchild 
        ? calculateTwoNodes(T->lchild) + calculateTwoNodes(T->rchild) + 1 
        : calculateTwoNodes(T->lchild) + calculateTwoNodes(T->rchild);
}
int calculateTwoNodes_2(BinaryTree T,int *n) {
    if (T) {
        if (T->lchild && T->rchild) (*n)++;
        calculateTwoNodes_2(T->lchild, n);
        calculateTwoNodes_2(T->rchild, n);
    }
}
```

## **8. 设B是一颗采用二叉链存储结构存储，编写一个把树B中的所有左右子树进行交换的函数**

```c
void swapChild(BinaryTree T) {
    if (T) {
        BinaryTreeNode* temp = T->lchild;
        T->lchild = T->rchild;
        T->rchild = temp;
        swapChild(T->lchild);
        swapChild(T->rchild);
    }
}
```

## **9. 假设二叉树采用 叉存储结构存储，设计一个算法，求先序遍历序列中第k（1<=k<=二叉树节点的个数）个节点的值**

```c
ElementType findKthPreOrder(BinaryTree T, int k) {
    static int count = 0;
    if (T == NULL) return -1; 
    count++;
    if (count == k) {
        return T->data;
    }
    ElementType val = findKthPreOrder(T->lchild, k);
    if (val != -1) return val;
    return findKthPreOrder(T->rchild, k);
}
```

 ## **10. 已知二叉树以二叉链表存储，编写算法完成：对于树中每个元素值为x的节点删除以它为根的子树，并释放相应空间 **

```c
// 递归删除子节点
void deleteTreeNode(BinaryTree T) {
    if (T) {
        deleteTreeNode(T->lchild);
        deleteTreeNode(T->rchild);
        free(T);
    }
}
bool deleteXTreeNode(BinaryTree T, int x) {
    if (!T)return false;
    if (T->data == x) {
        deleteTreeNode(T);
        return true;
    }
    Queue Q = initQueue();
    BinaryTreeNode* p;
    enterQueue(&Q, T);
    if (!isEmpty_queue(&Q)) {
        goOutQueue(&Q, &p);
        if (p->lchild) {
             if (p->lchild->data == x) {
                deleteTreeNode(p->lchild);
                p->lchild = NULL;
                return true;
            }
            else enterQueue(&Q, p->lchild);
       }
        if (p->rchild) {
            if (p->rchild->data == x) {
                deleteTreeNode(p->rchild);
                p->rchild = NULL;
                return true;
            }
            else enterQueue(&Q, p->rchild);
       }
    }
    return false;
}
```

## **11. 在二叉树中查找值为x的结点，试编写算法（用C语言）打印值为x的结点的所有祖先，假设值为x的结点不多于一个**

```c
typedef struct {
    BinaryTreeNode* n;
    int tag;
} Bn;
void findAncestor(BinaryTreeNode* T, int x) {
    Bn S[20]; // 栈，最多存储20个节点
    int top = -1; // 栈顶指针，初始化为-1
    while (T || top >= 0) { // 当树不为空或栈不为空
        while (T) { // 遍历左子树
            S[++top].n = T; // 将当前节点压入栈
            S[top].tag = 0; // 初始化标记为0
            T = T->lchild; // 移动到左子节点
        }
        // 如果找到了目标节点
        if (top >= 0 && S[top].n->data == x) {
            printf("所查结点的祖先为：");
                 printf("%d, ", S[i].n->data); // 输出祖先节点
            }
            printf("\n");
            return; // 找到后退出
        }
        // 处理栈顶元素的右子树
        while (top >= 0 && S[top].tag == 1) {
            top--; // 弹出栈顶元素
        }
        if (top >= 0) {
            S[top].tag = 1; // 标记为右子树已访问
            T = S[top].n->rchild; // 转到右子节点
        }
    }
    printf("未找到数据为 %d 的节点。\n", x); // 如果未找到节点
}
```

## **12. 设一棵二叉树的结点结构为(LLINK,INFO,RLINL)，Root为指向二叉树根结点的指针，p和q分别指向该二叉树中任意两个结点的指针，试编写算法ANCESTOR(Root,p,q,r)，找到p和q的最近公共祖先结点r**

```c
// 查找两个节点的最近公共祖先
BinaryTreeNode* searchCommonAncestor(BinaryTreeNode* root, BinaryTreeNode* p, BinaryTreeNode* q) {
    if (root == NULL) return NULL;
    // 用于递归查找
    if (root == p || root == q) {
        return root;
    }
    BinaryTreeNode* left = searchCommonAncestor(root->lchild, p, q);
    BinaryTreeNode* right = searchCommonAncestor(root->rchild, p, q);
    if (left && right) {
        return root; // 找到最近公共祖先
    }
    return left ? left : right; // 返回非空结果
}
```

