# 王道第158页代码题

## 3. 编写后序遍历树的非递归算法

```c
void postorder_2(BinaryTree T) {
    SequenceStack S = initSequenceStack();
    BinaryTreeNode* p = T;
    BinaryTreeNode* r = NULL;

    while (p || !isEmpty(&S)) {
        // 因为后序遍历的顺序是根左右，所以一直遍历左子树，找到最深层次的左子树
        if (p) {
            push(&S, p);
            p = p->lchild;
        }
        else {
         // 获取栈顶元素
            getTop(S, &p);
            if (p->rchild && p->rchild != r) {
                p = p->rchild;
            }
            else {
                pop(&S, &p);
                visit(p);
                r = p;
                p = NULL;
            }
        }
    }
}
```

## **4.试给出二叉树的自下而上、从左到右的层次遍历算法**

```c
void reverselayerorder(BinaryTreeNode* B) {
    if (B == NULL) {
        printf("树为空。\n");
        return;
    }
    Queue Q = initQueue();
    SequenceStack S = initSequenceStack();
    BinaryTreeNode* p;
    enterQueue(&Q, B);
    while (!isEmpty_queue(&Q)) {
        goOutQueue(&Q, &p);
        visit(p);
        push(&S,p);
        if (p->lchild != NULL) enterQueue(&Q, p->lchild);
        if (p->rchild != NULL) enterQueue(&Q, p->rchild);
    }
    printf("\n相反层次遍历：");
    while (!isEmpty(&S)) {
        p=pop(&S);
        printf("%d, ", p->data);
    }
}
```

## **5.  假设二叉树采用二叉链表树存储结构，设计一个非递归算法求二叉树的高度**

```c
int calculateHeightOfBinaryTree(BinaryTree T) {
    if (!T) return -1;
    Queue Q = initQueue();
    enterQueue(&Q, T);
    BinaryTreeNode* p;
    int last = 1, level = 0;
    while (!isEmpty_queue(&Q))
    {
        goOutQueue(&Q, &p);
        if (p->lchild)enterQueue(&Q, p->lchild);
        if (p->rchild)enterQueue(&Q, p->rchild);
        if (Q.front == last) {
            level++;
            last = Q.rear;
        }
    }
    return level;
}
// 递归版
int calculateHeightOfBinaryTree_2(BinaryTree T) {
    if (T==NULL)return 0;
    int ldepth = calculateHeightOfBinaryTree_2(T->lchild);
    int rdepth = calculateHeightOfBinaryTree_2(T->rchild);
    return (ldepth > rdepth ? ldepth : rdepth)+1;                         
}
```

## **6. 二叉树按二叉链表形式存储，试编写一个判断给定二叉树是否是完全二叉树的算法**

```c
bool isCompleteBinaryTree(BinaryTree T) {
    Queue Q = initQueue();
    enterQueue(&Q,T);
    BinaryTreeNode *p;
    while (!isEmpty_queue(&Q))
    {
        goOutQueue(&Q, &p);
        if (p) {
            enterQueue(&Q, p->lchild);
            enterQueue(&Q, p->rchild);
        }
        else {
            while (!isEmpty_queue(&Q))
            {
                goOutQueue(&Q, &p);
                if (p) {
                    return false;
                }
            }
        }
    }
    return true;
}
```

## **7. 假设二叉树是一个采用二叉链表结构存储的二叉树，试设计一个算法，计算一棵给定二叉树双分支节点的个数**

```c
int calculateTwoNodes(BinaryTree T) {
    if (!T)return 0;
    return T->lchild && T->rchild 
        ? calculateTwoNodes(T->lchild) + calculateTwoNodes(T->rchild) + 1 
        : calculateTwoNodes(T->lchild) + calculateTwoNodes(T->rchild);
}
int calculateTwoNodes_2(BinaryTree T,int *n) {
    if (T) {
        if (T->lchild && T->rchild) (*n)++;
        calculateTwoNodes_2(T->lchild, n);
        calculateTwoNodes_2(T->rchild, n);
    }
}
```

## **设B是一颗采用二叉链存储结构存储，编写一个把树B中的所有左右子树进行交换的函数**

```c
```

